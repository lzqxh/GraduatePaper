\section{伪代码}
本节里，我们会给出求解FVS问题的固定参数算法伪代码。
我们将算法分解成两个函数，Disjoint-FVS函数求解不相交反馈顶点集问题，FeedbackVertexSet函数是完整的反馈顶点集算法其中会调用到Disjoint-FVS函数。

首先给出Disjoint-FVS算法，如\ref{disjoint-fvs-algorithm}节所描述的这是一个分支搜索算法。
每次进入递归函数，首先应用收缩规则进行收缩，之后如果程序没有到达多项式可解或者到达不可能存在合法解的情形，我们选取顶点并进行分支搜索。具体伪代码，如下：\\

\begin{algorithm}
\caption{Disjoint-FVS算法}
\begin{algorithmic}[1]
\Require Disjoint问题实例$(G,U, D, k)$
\Ensure  符合条件的问题实例反馈顶点集合或者 “NO”
\algrule
\Function{Disjoint-FVS}{$G, U, D, k$}
    \State $G, U, D, k \gets ApplyReduceRlues(G, U, D, k)$ \Comment 首先应用收缩规则1-5
    \State $T \gets \{v \in D\;|\;\abs{N(v)} = 3 \text{ and } N(v) \subseteq U\}$
    \State $u_a \gets k, u_b \gets k + \frac{1}{2}cc(G[U]) - \abs{T}$
    \State \textbf{if} ($u_a < 0$) or ($u_b < 0$) \textbf{then} \Return "NO" \Comment 搜索终止条件，已经不可能存在解
    \If {$D = T$ }
        \State 在多项式时间内求解当前问题并返回结果 \Comment 引理\ref{Disjoint-FVSSolvable}
    \Else
        \State 取$D$中至少有3个邻居在$U$中的任一顶点$v$ 
        \State \Comment 引理\ref{vertexNDge3}表明这样的顶点一定存在
        \State $branchA \gets \text{Disjoint-FVS}(G \setminus v, U, D \setminus v, k - 1)$
        \Comment 分支1: $v \in FVS$
        \State \textbf{if} branchA不等于“NO” \textbf{then} \Return $branchA \cup \{v\}$
        \State \Return \text{Disjoint-FVS}$(G, U\cup\{v\}, D \setminus v, k)$
        \Comment 分支2: $v \notin FVS$
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm} 

\newpage
最后是完整的FVS问题算法，如前文所述其中我们使用了迭代压缩技术，通过依次加入每个顶点来最终求解完整问题实例。
期间，我们枚举完当前顶点覆盖集$Z$的子集后会构造Disjoint-FVS问题实例并会调用前面的Disjoint-FVS算法。
具体伪代码，如下：\\

\begin{algorithm}
\caption{FVS算法}
\begin{algorithmic}[1]
\Require FVS问题实例$(G,k)$
\Ensure  符合条件的问题实例反馈顶点集合或者 “NO”
\algrule
\Function{FVS}{$G, k$}
    \State $V_i \gets \emptyset, X \gets \emptyset$
    \For {遍历所有顶点$v\in V$}
        \State $V_i \gets V_i \cup v, G_i \gets G[V_i], D \gets V_i \setminus X$
        \State $Z \gets X \cup \{v\}$
        \State \textbf{If} $\abs{Z} \le k$ \textbf{then} 令$X \gets Z$并且\textbf{continue}
        \For {遍历所有Z的子集$Y \subseteq Z$}
            \State \textbf{If} $G[Z \setminus Y]$不是森林 \textbf{then} \textbf{continue}
            \State $result \gets \text{Disjoint-FVS}(G_i \setminus Y, Z \setminus Y, D, k - \abs{Y})$
            \State \textbf{If} $result$不是“NO” \textbf{then} 令$X \gets Y \cup result$并且\textbf{break}
        \EndFor
        \State \textbf{If} 对于所有Z的子集$result$均是“NO” \textbf{then} \Return “NO”
    \EndFor
    \State \Return X
\EndFunction
\end{algorithmic}
\end{algorithm} 
